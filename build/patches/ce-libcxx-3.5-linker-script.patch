This is 8241405ad42a8ce85c2a61baff5f96948f90cfa6
"[libcxx] Make it drastically simpler to link libc++.",
combined with a follow-up fix from
a15785bb5b644d92ea27b247d01be4f87b46307c
"Re-enable linker scripts after fixing bad CMake",
backported to 3.5.

diff --git a/libcxx/CMakeLists.txt b/libcxx/CMakeLists.txt
index c20e5d1cc2a0..6cdfefb4e9e3 100644
--- a/libcxx/CMakeLists.txt
+++ b/libcxx/CMakeLists.txt
@@ -52,6 +52,11 @@ set(LIBCXX_CXX_ABI "${LIBCXX_CXX_ABI}" CACHE STRING
     "Specify C++ ABI library to use." FORCE)
 set_property(CACHE LIBCXX_CXX_ABI PROPERTY STRINGS ;${CXXABIS})

+# Generate and install a linker script inplace of libc++.so. The linker script
+# will link libc++ to the correct ABI library.
+option(LIBCXX_ENABLE_ABI_LINKER_SCRIPT
+      "Use and install a linker script for the given ABI library" OFF)
+
 #===============================================================================
 # Configure System
 #===============================================================================
@@ -71,6 +76,21 @@ get_target_triple(LIBCXX_TARGET_TRIPLE
   )
 set(LIBCXX_TARGET_TRIPLE ${LIBCXX_TARGET_TRIPLE} CACHE STRING "Target triple.")

+if (LIBCXX_ENABLE_ABI_LINKER_SCRIPT)
+    if (APPLE)
+      message(FATAL_ERROR "LIBCXX_ENABLE_ABI_LINKER_SCRIPT cannot be used on APPLE targets")
+    endif()
+    if (NOT PYTHONINTERP_FOUND)
+      message(FATAL_ERROR "LIBCXX_ENABLE_ABI_LINKER_SCRIPT requires python but it was not found.")
+    endif()
+endif()
+
+if (LIBCXX_ENABLE_STATIC_ABI_LIBRARY AND LIBCXX_ENABLE_ABI_LINKER_SCRIPT)
+    message(FATAL_ERROR "Conflicting options given.
+        LIBCXX_ENABLE_STATIC_ABI_LIBRARY cannot be specified with
+        LIBCXX_ENABLE_ABI_LINKER_SCRIPT")
+endif()
+
 #===============================================================================
 # Add an ABI library if appropriate
 #===============================================================================
diff --git a/libcxx/lib/CMakeLists.txt b/libcxx/lib/CMakeLists.txt
index 70adcb722132..1c04b9b1b088 100644
--- a/libcxx/lib/CMakeLists.txt
+++ b/libcxx/lib/CMakeLists.txt
@@ -95,7 +95,36 @@ set_target_properties(cxx
     SOVERSION     "1"
   )

+# Generate a linker script inplace of a libc++.so symlink. Rerun this command
+# after cxx builds.
+if (LIBCXX_ENABLE_ABI_LINKER_SCRIPT)
+  # Get the name of the ABI library and handle the case where CXXABI_LIBNAME
+  # is a target name and not a library. Ex cxxabi_shared.
+  set(SCRIPT_ABI_LIBNAME "${CXXABI_LIBNAME}")
+  if (SCRIPT_ABI_LIBNAME STREQUAL "cxxabi")
+    set(SCRIPT_ABI_LIBNAME "c++abi")
+  endif()
+  # Generate a linker script inplace of a libc++.so symlink. Rerun this command
+  # after cxx builds.
+  add_custom_command(TARGET cxx POST_BUILD
+    COMMAND
+      ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/../utils/gen_link_script/gen_link_script.py
+    ARGS
+      "$<TARGET_LINKER_FILE:cxx>"
+      "${SCRIPT_ABI_LIBNAME}"
+    WORKING_DIRECTORY ${LIBCXX_BUILD_DIR}
+  )
+endif()
+
+
 install(TARGETS cxx
   LIBRARY DESTINATION lib
   ARCHIVE DESTINATION lib
   )
+# NOTE: This install command must go after the cxx install command otherwise
+# it will not be executed after the library symlinks are installed.
+if (LIBCXX_ENABLE_ABI_LINKER_SCRIPT)
+  install(FILES "$<TARGET_LINKER_FILE:cxx>"
+    DESTINATION lib${LIBCXX_LIBDIR_SUFFIX}
+    COMPONENT libcxx)
+endif()
diff --git a/libcxx/test/CMakeLists.txt b/libcxx/test/CMakeLists.txt
index 4810b2c57483..6673197b0d4e 100644
--- a/libcxx/test/CMakeLists.txt
+++ b/libcxx/test/CMakeLists.txt
@@ -30,6 +30,17 @@ if(PYTHONINTERP_FOUND)
   pythonize_bool(LIBCXX_ENABLE_SHARED)
   pythonize_bool(LIBCXX_HAS_STDCXX0X_FLAG)

+# The tests shouldn't link to any ABI library when it has been linked into
+# libc++ statically or via a linker script.
+if (LIBCXX_ENABLE_STATIC_ABI_LIBRARY OR LIBCXX_ENABLE_ABI_LINKER_SCRIPT)
+  set(LIBCXX_CXX_ABI_LIBNAME "none")
+endif()
+
+set(LIBCXX_TARGET_INFO "libcxx.test.target_info.LocalTI" CACHE STRING
+    "TargetInfo to use when setting up test environment.")
+set(LIBCXX_EXECUTOR "None" CACHE STRING
+    "Executor to use when running tests.")
+
   set(AUTO_GEN_COMMENT "## Autogenerated by libcxx configuration.\n# Do not edit!")

   configure_file(
diff --git a/libcxx/utils/gen_link_script/gen_link_script.py b/libcxx/utils/gen_link_script/gen_link_script.py
new file mode 100755
index 000000000000..5de18f9129c6
--- /dev/null
+++ b/libcxx/utils/gen_link_script/gen_link_script.py
@@ -0,0 +1,79 @@
+#!/usr/bin/env python
+import os
+import sys
+
+def print_and_exit(msg):
+    sys.stderr.write(msg + '\n')
+    sys.exit(1)
+
+def usage_and_exit():
+    print_and_exit("Usage: ./gen_link_script.py [--help] [--dryrun] <path/to/libcxx.so> <abi_libname>")
+
+def help_and_exit():
+    help_msg = \
+"""Usage
+
+  gen_link_script.py [--help] [--dryrun] <path/to/libcxx.so> <abi_libname>
+
+  Generate a linker script that links libc++ to the proper ABI library.
+  The script replaces the specified libc++ symlink.
+  An example script for c++abi would look like "INPUT(libc++.so.1 -lc++abi)".
+
+Arguments
+  <path/to/libcxx.so> - The top level symlink to the versioned libc++ shared
+                        library. This file is replaced with a linker script.
+  <abi_libname>       - The name of the ABI library to use in the linker script.
+                        The name must be one of [c++abi, stdc++, supc++, cxxrt].
+
+Exit Status:
+  0 if OK,
+  1 if the action failed.
+"""
+    print_and_exit(help_msg)
+
+def parse_args():
+    args = list(sys.argv)
+    del args[0]
+    if len(args) == 0:
+        usage_and_exit()
+    if args[0] == '--help':
+        help_and_exit()
+    dryrun = '--dryrun' == args[0]
+    if dryrun:
+        del args[0]
+    if len(args) != 2:
+        usage_and_exit()
+    symlink_file = args[0]
+    abi_libname = args[1]
+    return dryrun, symlink_file, abi_libname
+
+def main():
+    dryrun, symlink_file, abi_libname = parse_args()
+
+    # Check that the given libc++.so file is a valid symlink.
+    if not os.path.islink(symlink_file):
+        print_and_exit("symlink file %s is not a symlink" % symlink_file)
+
+    # Read the symlink so we know what libc++ to link to in the linker script.
+    linked_libcxx = os.readlink(symlink_file)
+
+    # Check that the abi_libname is one of the supported values.
+    supported_abi_list = ['c++abi', 'stdc++', 'supc++', 'cxxrt']
+    if abi_libname not in supported_abi_list:
+        print_and_exit("abi name '%s' is not supported: Use one of %r" %
+                        (abi_libname, supported_abi_list))
+
+    # Generate the linker script contents and print the script and destination
+    # information.
+    contents = "INPUT(%s -l%s)" % (linked_libcxx, abi_libname)
+    print("GENERATING SCRIPT: '%s' as file %s" % (contents, symlink_file))
+
+    # Remove the existing libc++ symlink and replace it with the script.
+    if not dryrun:
+        os.unlink(symlink_file)
+        with open(symlink_file, 'w') as f:
+            f.write(contents + "\n")
+
+
+if __name__ == '__main__':
+    main()
 